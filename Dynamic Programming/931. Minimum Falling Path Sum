import java.util.*;

class Solution {

    public static int path(int[][] matrix, int[][] dp, int i, int j, int m, int n) {

        if (j < 0 || j >= n) return (int) 1e9;
        if (i == m - 1) return matrix[i][j];

        if (dp[i][j] != -200) return dp[i][j];

        int left  = matrix[i][j] + path(matrix, dp, i + 1, j - 1,m,n);
        int down  = matrix[i][j] + path(matrix, dp, i + 1, j,m,n);
        int right = matrix[i][j] + path(matrix, dp, i + 1, j + 1,m,n);
       

        return dp[i][j] = Math.min(left, Math.min(down, right));
    }

    public int minFallingPathSum(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dp[i], -200);
        }

        int min = Integer.MAX_VALUE;
        for (int j = 0; j < n; j++) {
            min = Math.min(min, path(matrix, dp, 0, j,m,n));
        }

        return min;
    }
}
/*
class Solution {
    public static int path(int[][] matrix, int[][] dp,int i, int j) {
        if(j<0 || j>matrix[0].length-1) return (int)(1e9);
        if(i==0) return matrix[i][j];

        if(dp[i][j] != -200) return dp[i][j];

        int left  = matrix[i][j] + path(matrix, dp, i-1, j-1);
        int top   = matrix[i][j] + path(matrix, dp, i-1, j);
        int right = matrix[i][j] + path(matrix, dp, i-1, j+1);

        dp[i][j] = Math.min(left, Math.min(top, right));
        return dp[i][j];
    }
    public int minFallingPathSum(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        int dp[][] = new int[m][n];
        for(int i=0; i<m; i++){
            Arrays.fill(dp[i], -200);
        }
        int min = Integer.MAX_VALUE;
        for(int i=0; i<n; i++){
            min = Math.min(min, path(matrix, dp, m-1, i));
        }
        return min;
    }
}

*/
